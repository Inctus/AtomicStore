{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Introduction \u00b6 Description \u00b6 AtomicStore is a lightweight wrapper allowing easy creation of custom DataStores ready for a pseudo-atomic DataBase on Roblox. DataStores instanciated with this module abstract all the useless boilerplate code for safe lookups, and give you everything you need to implement features such as session locking and caching, whilst still allowing you the level of control you need to properly manage a pseudo-atomic transactional database on Roblox. This module is aimed at high-level developers, and provides no inbuilt safeguarding or rate limiting. If you're looking for a simpler solution then see either ProfileService by loleris or DataStore2 by kampfkarren . Project Layout \u00b6 The project follows a simple modular layout, with the MainModule being AtomicStore.lua . Lua/ AtomicStore.lua Dependencies/ Classes/ GeneralStore.lua MultiStore.lua TrackedStore.lua TrackedMultiStore.lua Shared/ Utility.lua Here, the Utility.lua file contains a set of functions for safe access to DataStores, taking into account DataStoreBudgets and catching errors. Use the installer to properly install the module and update it when you want to. This is properly documented in the installation guide. Why AtomicStore? \u00b6 AtomicStore is a low level wrapper of pure datastores, preserving the same level of control and the accessibility you would get from creating your own system from scratch. If you're looking to create your own system, without dealing with unnecessary API, then this could be the option for you. The API for this store mimics Roblox's It is simple, and intuitive to learn, and the data handling functions mimic the inbuilt DataStore functions meaning that it is really simple to learn and use this module, if you're used to working with pure DataStores.","title":"Introduction"},{"location":"#introduction","text":"","title":"Introduction"},{"location":"#description","text":"AtomicStore is a lightweight wrapper allowing easy creation of custom DataStores ready for a pseudo-atomic DataBase on Roblox. DataStores instanciated with this module abstract all the useless boilerplate code for safe lookups, and give you everything you need to implement features such as session locking and caching, whilst still allowing you the level of control you need to properly manage a pseudo-atomic transactional database on Roblox. This module is aimed at high-level developers, and provides no inbuilt safeguarding or rate limiting. If you're looking for a simpler solution then see either ProfileService by loleris or DataStore2 by kampfkarren .","title":"Description"},{"location":"#project-layout","text":"The project follows a simple modular layout, with the MainModule being AtomicStore.lua . Lua/ AtomicStore.lua Dependencies/ Classes/ GeneralStore.lua MultiStore.lua TrackedStore.lua TrackedMultiStore.lua Shared/ Utility.lua Here, the Utility.lua file contains a set of functions for safe access to DataStores, taking into account DataStoreBudgets and catching errors. Use the installer to properly install the module and update it when you want to. This is properly documented in the installation guide.","title":"Project Layout"},{"location":"#why-atomicstore","text":"AtomicStore is a low level wrapper of pure datastores, preserving the same level of control and the accessibility you would get from creating your own system from scratch. If you're looking to create your own system, without dealing with unnecessary API, then this could be the option for you. The API for this store mimics Roblox's It is simple, and intuitive to learn, and the data handling functions mimic the inbuilt DataStore functions meaning that it is really simple to learn and use this module, if you're used to working with pure DataStores.","title":"Why AtomicStore?"},{"location":"Installation/","text":"Installation \u00b6 Simple Installation \u00b6 Simply run require(6697537150) in the Studio Command Bar. Rojo Installation \u00b6 Setup with Rojo . Fork AtomicStore's Repository .. Clone the Forked Repository into your Local Repository. Modify default.project.json to set the desired location of the AtomicStore module. Run rojo serve .","title":"Installation"},{"location":"Installation/#installation","text":"","title":"Installation"},{"location":"Installation/#simple-installation","text":"Simply run require(6697537150) in the Studio Command Bar.","title":"Simple Installation"},{"location":"Installation/#rojo-installation","text":"Setup with Rojo . Fork AtomicStore's Repository .. Clone the Forked Repository into your Local Repository. Modify default.project.json to set the desired location of the AtomicStore module. Run rojo serve .","title":"Rojo Installation"},{"location":"Methodology/","text":"Methodology \u00b6 Universal Methods \u00b6 Safe Lookups \u00b6 DataStore lookups are asynchronous calls, that can error for a variety of reasons. By using a lightweight pcall wrapper function and waiting for the DataStore budget for the request type in question to be available, I minimise the risk of a surplus amount of invocations happening, while keeping the method lightweight. Tracking Methods \u00b6 Mutliple Stores \u00b6 TrackedMultiStore s use multiple DataStore s with a single OrderedDataStore for the version history. Each DataStore within the main TrackedStore acts independently so you should use PullData sparingly. Version History \u00b6 TrackedStores , be it of either the Multi or Single variety, rely on the same methodology, which I first encountered on the DevForum referenced as Berezza's Method. This involves using an OrderedDataStore to keep track of save keys, by ordering them according to their timestamps, which means a simple descending lookup can find the recentmost save keys. Then, a separate call has to be made to extract the data from that save key from a regular DataStore . By managing save keys, you can create a solid system using Session-Locking, and maintain atomicity of data in the database. TrackedStores UpdateData method is in place It doesn't create a new index in the VersionHistory since this would mean that too many API calls would happen simultaneously, removing the advantages that UpdateAsync offers. Library Methods \u00b6 Data Slicing \u00b6 LibraryStore s allow for an infinite input data size by slicing it up into chunks, and then assigning each chunk a contiguous DataStore key, for easy retrieval. It essentially mimics an array with a variable starting index, similar to a Displacement Addressing Mode, which is essentially Indexed Addressing with no fixed start position. Multiple Stores \u00b6 LibraryStore s use multiple DataStore s, one for each slice of data, and another for metadata assosciated with the save. Maintaining Atomicity \u00b6 LibraryStore s maintain atomicity by not overwriting data ever. This means that if a PullData / PushData call fails at any point, cancelling it will not require any subsequent DataStore calls.","title":"Methology"},{"location":"Methodology/#methodology","text":"","title":"Methodology"},{"location":"Methodology/#universal-methods","text":"","title":"Universal Methods"},{"location":"Methodology/#safe-lookups","text":"DataStore lookups are asynchronous calls, that can error for a variety of reasons. By using a lightweight pcall wrapper function and waiting for the DataStore budget for the request type in question to be available, I minimise the risk of a surplus amount of invocations happening, while keeping the method lightweight.","title":"Safe Lookups"},{"location":"Methodology/#tracking-methods","text":"","title":"Tracking Methods"},{"location":"Methodology/#mutliple-stores","text":"TrackedMultiStore s use multiple DataStore s with a single OrderedDataStore for the version history. Each DataStore within the main TrackedStore acts independently so you should use PullData sparingly.","title":"Mutliple Stores"},{"location":"Methodology/#version-history","text":"TrackedStores , be it of either the Multi or Single variety, rely on the same methodology, which I first encountered on the DevForum referenced as Berezza's Method. This involves using an OrderedDataStore to keep track of save keys, by ordering them according to their timestamps, which means a simple descending lookup can find the recentmost save keys. Then, a separate call has to be made to extract the data from that save key from a regular DataStore . By managing save keys, you can create a solid system using Session-Locking, and maintain atomicity of data in the database. TrackedStores UpdateData method is in place It doesn't create a new index in the VersionHistory since this would mean that too many API calls would happen simultaneously, removing the advantages that UpdateAsync offers.","title":"Version History"},{"location":"Methodology/#library-methods","text":"","title":"Library Methods"},{"location":"Methodology/#data-slicing","text":"LibraryStore s allow for an infinite input data size by slicing it up into chunks, and then assigning each chunk a contiguous DataStore key, for easy retrieval. It essentially mimics an array with a variable starting index, similar to a Displacement Addressing Mode, which is essentially Indexed Addressing with no fixed start position.","title":"Data Slicing"},{"location":"Methodology/#multiple-stores","text":"LibraryStore s use multiple DataStore s, one for each slice of data, and another for metadata assosciated with the save.","title":"Multiple Stores"},{"location":"Methodology/#maintaining-atomicity","text":"LibraryStore s maintain atomicity by not overwriting data ever. This means that if a PullData / PushData call fails at any point, cancelling it will not require any subsequent DataStore calls.","title":"Maintaining Atomicity"},{"location":"API/AtomicStore/","text":"AtomicStore Top-Level Singleton \u00b6 Initialisation \u00b6 require() \u00b6 local AtomicStore = require ( Path / To / AtomicStore ) Retrieval Functions \u00b6 Retrieval functions expose the constructors Each class can be accessed via a retrieval function with its name. :RetrieveGeneralStore() \u00b6 local GeneralStore = AtomicStore : RetrieveGeneralStore ( < string name > , < string scope > ) Returns GeneralStore instance. See GeneralStore . :RetrieveMultiStore() \u00b6 local MultiStore = AtomicStore : RetrieveMultiStore ( < string name > , < string scope > ) Returns MultiStore instance. See MultiStore . :RetrieveTrackedStore() \u00b6 local TrackedStore = AtomicStore : RetrieveTrackedStore ( < string name > , < string scope > ) Returns TrackedStore instance. See TrackedStore . :RetrieveTrackedMultiStore() \u00b6 local TrackedMultiStore = AtomicStore : RetrieveTrackedMultiStore ( < string name > , < string scope > , < array < string data_name > data_store_names > ) Returns TrackedMultiStore instance. See TrackedMultiStore . :RetrieveLibraryStore() \u00b6 local LibraryStore = AtomicStore : RetrieveLibraryStore ( < string name > , < string scope > ) Returns LibraryStore instance. See LibraryStore . Store Management \u00b6 :GetStores() \u00b6 local DataStores = AtomicStore : GetStores () Returns <array <variant datastore> datastores> :FindFirstStoreByName() \u00b6 local DataStore = AtomicStore : FindFirstStoreByName ( < string name > ) Returns <variant datastore> Names are declared via initialisation of the DataStore They are obtained throught the name parameter of the constructor.","title":"AtomicStore"},{"location":"API/AtomicStore/#atomicstore-top-level-singleton","text":"","title":"AtomicStore Top-Level Singleton"},{"location":"API/AtomicStore/#initialisation","text":"","title":"Initialisation"},{"location":"API/AtomicStore/#require","text":"local AtomicStore = require ( Path / To / AtomicStore )","title":"require()"},{"location":"API/AtomicStore/#retrieval-functions","text":"Retrieval functions expose the constructors Each class can be accessed via a retrieval function with its name.","title":"Retrieval Functions"},{"location":"API/AtomicStore/#retrievegeneralstore","text":"local GeneralStore = AtomicStore : RetrieveGeneralStore ( < string name > , < string scope > ) Returns GeneralStore instance. See GeneralStore .","title":":RetrieveGeneralStore()"},{"location":"API/AtomicStore/#retrievemultistore","text":"local MultiStore = AtomicStore : RetrieveMultiStore ( < string name > , < string scope > ) Returns MultiStore instance. See MultiStore .","title":":RetrieveMultiStore()"},{"location":"API/AtomicStore/#retrievetrackedstore","text":"local TrackedStore = AtomicStore : RetrieveTrackedStore ( < string name > , < string scope > ) Returns TrackedStore instance. See TrackedStore .","title":":RetrieveTrackedStore()"},{"location":"API/AtomicStore/#retrievetrackedmultistore","text":"local TrackedMultiStore = AtomicStore : RetrieveTrackedMultiStore ( < string name > , < string scope > , < array < string data_name > data_store_names > ) Returns TrackedMultiStore instance. See TrackedMultiStore .","title":":RetrieveTrackedMultiStore()"},{"location":"API/AtomicStore/#retrievelibrarystore","text":"local LibraryStore = AtomicStore : RetrieveLibraryStore ( < string name > , < string scope > ) Returns LibraryStore instance. See LibraryStore .","title":":RetrieveLibraryStore()"},{"location":"API/AtomicStore/#store-management","text":"","title":"Store Management"},{"location":"API/AtomicStore/#getstores","text":"local DataStores = AtomicStore : GetStores () Returns <array <variant datastore> datastores>","title":":GetStores()"},{"location":"API/AtomicStore/#findfirststorebyname","text":"local DataStore = AtomicStore : FindFirstStoreByName ( < string name > ) Returns <variant datastore> Names are declared via initialisation of the DataStore They are obtained throught the name parameter of the constructor.","title":":FindFirstStoreByName()"},{"location":"API/GeneralStore/","text":"GeneralStore - Single Untracked \u00b6 Constructors \u00b6 .new() \u00b6 local GeneralStore = GeneralStore . new ( < string name > , < string scope > ) Returns <instance GeneralStore> This is not accessed directly by the user Instead, you access it via AtomicStore:RetrieveGeneralStore(...) Methods \u00b6 :PullData() \u00b6 local data = GeneralStore : PullData () Returns <variant data> Since GeneralStore is a single key store This method accepts no save_key parameter :PushData() \u00b6 local success = GeneralStore : PushData ( < variant data > ) Returns <bool success> :UpdateData() \u00b6 local new_data = GeneralStore : UpdateData ( < func update_function > ) Returns <variant new_data>","title":"GeneralStore"},{"location":"API/GeneralStore/#generalstore-single-untracked","text":"","title":"GeneralStore - Single Untracked"},{"location":"API/GeneralStore/#constructors","text":"","title":"Constructors"},{"location":"API/GeneralStore/#new","text":"local GeneralStore = GeneralStore . new ( < string name > , < string scope > ) Returns <instance GeneralStore> This is not accessed directly by the user Instead, you access it via AtomicStore:RetrieveGeneralStore(...)","title":".new()"},{"location":"API/GeneralStore/#methods","text":"","title":"Methods"},{"location":"API/GeneralStore/#pulldata","text":"local data = GeneralStore : PullData () Returns <variant data> Since GeneralStore is a single key store This method accepts no save_key parameter","title":":PullData()"},{"location":"API/GeneralStore/#pushdata","text":"local success = GeneralStore : PushData ( < variant data > ) Returns <bool success>","title":":PushData()"},{"location":"API/GeneralStore/#updatedata","text":"local new_data = GeneralStore : UpdateData ( < func update_function > ) Returns <variant new_data>","title":":UpdateData()"},{"location":"API/LibraryStore/","text":"LibraryStore - Library Untracked \u00b6 Constructors \u00b6 .new() \u00b6 local LibraryStore = LibraryStore . new ( < string name > , < string scope > ) Returns <instance LibraryStore> This is not accessed directly by the user Instead, you access it via AtomicStore:RetrieveLibraryStore(...) Methods \u00b6 :PullData() \u00b6 local data = LibraryStore : PullData () Returns <variant data> This function returns a set of aggregated decoded data It uses multiple GetAsync() calls and will consume your budget if the data requested is extremely large. :PullSaveMetaData() \u00b6 local metadata = LibraryStore : PullSaveMetaData () Returns <dictionary metadata> This is an internal function It returns metadata in the format: { start = < integer start_index > , length = < integer length > } :PullDataFromKey() \u00b6 local slice = LibraryStore : PullDataFromKey ( < string save_key > ) Returns <string slice> This returns a JSON slice of the saved data It will need to be aggregated to be decoded, or you can parse it as you want to create a random lookup. :PushData() \u00b6 local success = LibraryStore : PushData ( < variant data > end ) Returns <bool success> This polls for recentmost metadata It uses no caching. If it fails, it will not break or overwrite data. It will eat SetAsync requests.","title":"LibraryStore"},{"location":"API/LibraryStore/#librarystore-library-untracked","text":"","title":"LibraryStore - Library Untracked"},{"location":"API/LibraryStore/#constructors","text":"","title":"Constructors"},{"location":"API/LibraryStore/#new","text":"local LibraryStore = LibraryStore . new ( < string name > , < string scope > ) Returns <instance LibraryStore> This is not accessed directly by the user Instead, you access it via AtomicStore:RetrieveLibraryStore(...)","title":".new()"},{"location":"API/LibraryStore/#methods","text":"","title":"Methods"},{"location":"API/LibraryStore/#pulldata","text":"local data = LibraryStore : PullData () Returns <variant data> This function returns a set of aggregated decoded data It uses multiple GetAsync() calls and will consume your budget if the data requested is extremely large.","title":":PullData()"},{"location":"API/LibraryStore/#pullsavemetadata","text":"local metadata = LibraryStore : PullSaveMetaData () Returns <dictionary metadata> This is an internal function It returns metadata in the format: { start = < integer start_index > , length = < integer length > }","title":":PullSaveMetaData()"},{"location":"API/LibraryStore/#pulldatafromkey","text":"local slice = LibraryStore : PullDataFromKey ( < string save_key > ) Returns <string slice> This returns a JSON slice of the saved data It will need to be aggregated to be decoded, or you can parse it as you want to create a random lookup.","title":":PullDataFromKey()"},{"location":"API/LibraryStore/#pushdata","text":"local success = LibraryStore : PushData ( < variant data > end ) Returns <bool success> This polls for recentmost metadata It uses no caching. If it fails, it will not break or overwrite data. It will eat SetAsync requests.","title":":PushData()"},{"location":"API/MultiStore/","text":"MultiStore - Multi Untracked \u00b6 Constructors \u00b6 .new() \u00b6 local MultiStore = MultiStore . new ( < string name > , < string scope > ) Returns <instance MultiStore> This is not accessed directly by the user Instead, you access it via AtomicStore:RetrieveMultiStore(...) Methods \u00b6 :PullData() \u00b6 local data = MultiStore : PullData ( < string save_key > ) Returns <variant data> :PushData() \u00b6 local success = MultiStore : PushData ( < string save_key > , < variant data > ) Returns <bool success> :UpdateData() \u00b6 local new_data = GeneralStore : UpdateData ( < string save_key > , < func update_function > ) Returns <variant new_data>","title":"MultiStore"},{"location":"API/MultiStore/#multistore-multi-untracked","text":"","title":"MultiStore - Multi Untracked"},{"location":"API/MultiStore/#constructors","text":"","title":"Constructors"},{"location":"API/MultiStore/#new","text":"local MultiStore = MultiStore . new ( < string name > , < string scope > ) Returns <instance MultiStore> This is not accessed directly by the user Instead, you access it via AtomicStore:RetrieveMultiStore(...)","title":".new()"},{"location":"API/MultiStore/#methods","text":"","title":"Methods"},{"location":"API/MultiStore/#pulldata","text":"local data = MultiStore : PullData ( < string save_key > ) Returns <variant data>","title":":PullData()"},{"location":"API/MultiStore/#pushdata","text":"local success = MultiStore : PushData ( < string save_key > , < variant data > ) Returns <bool success>","title":":PushData()"},{"location":"API/MultiStore/#updatedata","text":"local new_data = GeneralStore : UpdateData ( < string save_key > , < func update_function > ) Returns <variant new_data>","title":":UpdateData()"},{"location":"API/TrackedMultiStore/","text":"TrackedMultiStore - Multi Tracked \u00b6 Constructors \u00b6 .new() \u00b6 local TrackedMultiStore = TrackedMultiStore . new ( < string name > , < string scope > , < array < string data_store_name > data_store_names > ) Returns <instance TrackedMultiStore> This is not accessed directly by the user Instead, you access it via AtomicStore:RetrieveTrackedMultiStore(...) DataStoreNames act as actual sub-datastores Instead of using one DataStore like a TrackedStore does, TrackedMultiStores use multiple DataStores. Methods \u00b6 :PullData() \u00b6 local data , save_key = TrackedMultiStore : PullData ( < integer depth > ) Returns <dict <variant data> extracted_data>, <string save_key> Depth refers to depth in VersionHistory If you wanted to pull the 3rd most recent save, then you'd use depth 3 The indices of the dict extracted_data Come from the names you provided in the constructor. :PullDataFromKey() \u00b6 local data , save_key = TrackedMultiStore : PullDataFromKey ( < string save_key > ) Returns <dict <variant data> extracted_data>, <string save_key> The save_key here must be obtained from one of the GetKey methods These are :GetSaveKeys() and :GetSaveKey() and expose the internal OrderedDatastore allowing for more complex VersionHistory manipulation. The indices of the dict extracted_data Come from the names you provided in the constructor. :GetSaveKey() \u00b6 local save_key = TrackedMultiStore : GetSaveKey ( < integer depth > ) Returns <string save_key> :GetSaveKeys() \u00b6 local save_keys = TrackedMultiStore : GetSaveKeys ( < integer depth > ) Returns <array <string save_key> save_keys> This returns the recentmost save keys up to depth It uses one poll of the OrderedDataStore so is useful if you want to access multiple saves simultaneously. :PushData() \u00b6 local success , save_key = TrackedMultiStore : PushData ( < dict < variant data > data_dict > ) Returns <bool success>, <string save_key> This function creates a new key This is not an in-place update, but instead creates a new save key and updates the version history. You can \"rewind\" this action. The dict data_dict indices must match the constructor As a good practice, operate on the extracted info without mutating the keys and you will be fine to then send it back here. :UpdateData() \u00b6 local new_data , save_key = TrackedMultiStore : UpdateData ( < integer depth > , < func update_function > ) Returns <dict <variant new_data> extracted_data>, <string save_key> This function is in-place It operates on the save provided at the specified depth. This is useful if you want to create session locking since it exposes the UpdateAsync method. It shouldn't be used for saving if you want to retain a VersionHistory. It can be used to retrieve data from the store. This function is applied to all sub-stores individually It should take parameters data_store_name and old_data: function update_function ( data_name , old_data ) -- do magic return magic end The extracted_data dictionary's keys match the DataStore names provided :UpdateDataFromKey() \u00b6 local new_data , save_key = TrackedMultiStore : UpdateData ( < string save_key > , < func update_function > ) Returns <dict <variant new_data> extracted_data>, <string save_key>","title":"TrackedMultiStore"},{"location":"API/TrackedMultiStore/#trackedmultistore-multi-tracked","text":"","title":"TrackedMultiStore - Multi Tracked"},{"location":"API/TrackedMultiStore/#constructors","text":"","title":"Constructors"},{"location":"API/TrackedMultiStore/#new","text":"local TrackedMultiStore = TrackedMultiStore . new ( < string name > , < string scope > , < array < string data_store_name > data_store_names > ) Returns <instance TrackedMultiStore> This is not accessed directly by the user Instead, you access it via AtomicStore:RetrieveTrackedMultiStore(...) DataStoreNames act as actual sub-datastores Instead of using one DataStore like a TrackedStore does, TrackedMultiStores use multiple DataStores.","title":".new()"},{"location":"API/TrackedMultiStore/#methods","text":"","title":"Methods"},{"location":"API/TrackedMultiStore/#pulldata","text":"local data , save_key = TrackedMultiStore : PullData ( < integer depth > ) Returns <dict <variant data> extracted_data>, <string save_key> Depth refers to depth in VersionHistory If you wanted to pull the 3rd most recent save, then you'd use depth 3 The indices of the dict extracted_data Come from the names you provided in the constructor.","title":":PullData()"},{"location":"API/TrackedMultiStore/#pulldatafromkey","text":"local data , save_key = TrackedMultiStore : PullDataFromKey ( < string save_key > ) Returns <dict <variant data> extracted_data>, <string save_key> The save_key here must be obtained from one of the GetKey methods These are :GetSaveKeys() and :GetSaveKey() and expose the internal OrderedDatastore allowing for more complex VersionHistory manipulation. The indices of the dict extracted_data Come from the names you provided in the constructor.","title":":PullDataFromKey()"},{"location":"API/TrackedMultiStore/#getsavekey","text":"local save_key = TrackedMultiStore : GetSaveKey ( < integer depth > ) Returns <string save_key>","title":":GetSaveKey()"},{"location":"API/TrackedMultiStore/#getsavekeys","text":"local save_keys = TrackedMultiStore : GetSaveKeys ( < integer depth > ) Returns <array <string save_key> save_keys> This returns the recentmost save keys up to depth It uses one poll of the OrderedDataStore so is useful if you want to access multiple saves simultaneously.","title":":GetSaveKeys()"},{"location":"API/TrackedMultiStore/#pushdata","text":"local success , save_key = TrackedMultiStore : PushData ( < dict < variant data > data_dict > ) Returns <bool success>, <string save_key> This function creates a new key This is not an in-place update, but instead creates a new save key and updates the version history. You can \"rewind\" this action. The dict data_dict indices must match the constructor As a good practice, operate on the extracted info without mutating the keys and you will be fine to then send it back here.","title":":PushData()"},{"location":"API/TrackedMultiStore/#updatedata","text":"local new_data , save_key = TrackedMultiStore : UpdateData ( < integer depth > , < func update_function > ) Returns <dict <variant new_data> extracted_data>, <string save_key> This function is in-place It operates on the save provided at the specified depth. This is useful if you want to create session locking since it exposes the UpdateAsync method. It shouldn't be used for saving if you want to retain a VersionHistory. It can be used to retrieve data from the store. This function is applied to all sub-stores individually It should take parameters data_store_name and old_data: function update_function ( data_name , old_data ) -- do magic return magic end The extracted_data dictionary's keys match the DataStore names provided","title":":UpdateData()"},{"location":"API/TrackedMultiStore/#updatedatafromkey","text":"local new_data , save_key = TrackedMultiStore : UpdateData ( < string save_key > , < func update_function > ) Returns <dict <variant new_data> extracted_data>, <string save_key>","title":":UpdateDataFromKey()"},{"location":"API/TrackedStore/","text":"TrackedStore - Single Tracked \u00b6 Constructors \u00b6 .new() \u00b6 local TrackedStore = TrackedStore . new ( < string name > , < string scope > ) Returns <instance TrackedStore> This is not accessed directly by the user Instead, you access it via AtomicStore:RetrieveTrackedStore(...) Methods \u00b6 :PullData() \u00b6 local data , save_key = TrackedStore : PullData ( < integer depth > ) Returns <variant data>, <string save_key> Depth refers to depth in VersionHistory If you wanted to pull the 3rd most recent save, then you'd use depth 3 :PullDataFromKey() \u00b6 local data , save_key = TrackedStore : PullDataFromKey ( < string save_key > ) Returns <variant data>, <string save_key> The save_key here must be obtained from one of the GetKey methods These are :GetSaveKeys() and :GetSaveKey() and expose the internal OrderedDatastore allowing for more complex VersionHistory manipulation. :GetSaveKey() \u00b6 local save_key = TrackedStore : GetSaveKey ( < integer depth > ) Returns <string save_key> :GetSaveKeys() \u00b6 local save_keys = TrackedStore : GetSaveKeys ( < integer depth > ) Returns <array <string save_key> save_keys> This returns the recentmost save keys up to depth It uses one poll of the OrderedDataStore so is useful if you want to access multiple saves simultaneously. :PushData() \u00b6 local success , save_key = TrackedStore : PushData ( < variant data > ) Returns <bool success>, <string save_key> This function creates a new key This is not an in-place update, but instead creates a new save key and updates the version history. You can \"rewind\" this action. :UpdateData() \u00b6 local new_data , save_key = TrackedStore : UpdateData ( < integer depth > , < func update_function > ) Returns <variant new_data>, <string save_key> This function is in-place It operates on the save provided at the specified depth. This is useful if you want to create session locking since it exposes the UpdateAsync method. It shouldn't be used for saving if you want to retain a VersionHistory. It can be used to retrieve data from the store. :UpdateDataFromKey() \u00b6 local new_data , save_key = TrackedStore : UpdateDataFromKey ( < string save_key > , < func update_function > ) Returns <variant new_data>, <string save_key>","title":"TrackedStore"},{"location":"API/TrackedStore/#trackedstore-single-tracked","text":"","title":"TrackedStore - Single Tracked"},{"location":"API/TrackedStore/#constructors","text":"","title":"Constructors"},{"location":"API/TrackedStore/#new","text":"local TrackedStore = TrackedStore . new ( < string name > , < string scope > ) Returns <instance TrackedStore> This is not accessed directly by the user Instead, you access it via AtomicStore:RetrieveTrackedStore(...)","title":".new()"},{"location":"API/TrackedStore/#methods","text":"","title":"Methods"},{"location":"API/TrackedStore/#pulldata","text":"local data , save_key = TrackedStore : PullData ( < integer depth > ) Returns <variant data>, <string save_key> Depth refers to depth in VersionHistory If you wanted to pull the 3rd most recent save, then you'd use depth 3","title":":PullData()"},{"location":"API/TrackedStore/#pulldatafromkey","text":"local data , save_key = TrackedStore : PullDataFromKey ( < string save_key > ) Returns <variant data>, <string save_key> The save_key here must be obtained from one of the GetKey methods These are :GetSaveKeys() and :GetSaveKey() and expose the internal OrderedDatastore allowing for more complex VersionHistory manipulation.","title":":PullDataFromKey()"},{"location":"API/TrackedStore/#getsavekey","text":"local save_key = TrackedStore : GetSaveKey ( < integer depth > ) Returns <string save_key>","title":":GetSaveKey()"},{"location":"API/TrackedStore/#getsavekeys","text":"local save_keys = TrackedStore : GetSaveKeys ( < integer depth > ) Returns <array <string save_key> save_keys> This returns the recentmost save keys up to depth It uses one poll of the OrderedDataStore so is useful if you want to access multiple saves simultaneously.","title":":GetSaveKeys()"},{"location":"API/TrackedStore/#pushdata","text":"local success , save_key = TrackedStore : PushData ( < variant data > ) Returns <bool success>, <string save_key> This function creates a new key This is not an in-place update, but instead creates a new save key and updates the version history. You can \"rewind\" this action.","title":":PushData()"},{"location":"API/TrackedStore/#updatedata","text":"local new_data , save_key = TrackedStore : UpdateData ( < integer depth > , < func update_function > ) Returns <variant new_data>, <string save_key> This function is in-place It operates on the save provided at the specified depth. This is useful if you want to create session locking since it exposes the UpdateAsync method. It shouldn't be used for saving if you want to retain a VersionHistory. It can be used to retrieve data from the store.","title":":UpdateData()"},{"location":"API/TrackedStore/#updatedatafromkey","text":"local new_data , save_key = TrackedStore : UpdateDataFromKey ( < string save_key > , < func update_function > ) Returns <variant new_data>, <string save_key>","title":":UpdateDataFromKey()"},{"location":"Resources/BestPractices/","text":"Best Practices \u00b6 Failure Detection \u00b6 Failures are all wrapped in pcalls and are detected when you receive a value of false from the PullData / PushData / UpdateData call, followed by an error message. Here's an example: local data , code = GeneralStore : PullData () if data == false then -- failed elseif data == nil then -- no data else -- data end For this reason storing false by itself will lead to ambiguities Try to avoid storing boolean values directly since it will interfere with your error catching/monitoring. Store Usage \u00b6 GeneralStore \u00b6 GeneralStore s provide an interface with a small amount of data, through a single key, with no history. This means that they are not ideal for saving whole sets of player data, but are instead suited more to saving single entities. MultiStore \u00b6 MultiStore s provide an interface with a small amount of data, through many keys, with no history. This means that they are ideal for tracking multi-key entities such as Items, with each UID having their own keys. If Atomicity is important, use UpdateData in preference to PullData / PushData This is due to UpdateData exposing the inbuilt UpdateAsync method, which A) doesn't cache, B) doesn't have the same 6 second key limit, C) retries until it performs its intended purpose, D) is cancellable, by returning nil . TrackedStore \u00b6 TrackedStore s provide an interface with a large amount of data, through a single key, with a version history. This means it is suited to storing a regular amount of player data, in a regular game scenario, and since it has a 1:1 PullData - GetAsync call ratio, it will not consume your data budgets unnecessarily. You're advised to use this as a main data store, and not an entity store Access it using PullData and PushData and apply session locking with UpdateData since pulling and pushing isn't guaranteed to be atomic. TrackedMultiStore \u00b6 TrackedMultiStore s provide an interface with an even larger amount of data, through multiple keys, with a shared version history. It is suited to a large amount of player data, such as storing house arrangements, since it has a 1:many PullData - GetAsync call ratio, it is advised to use TrackedStores wherever possible. You're advised to use this as a main data store, and not an entity store Access it using PullData and PushData and apply session locking with UpdateData since pulling and pushing isn't guaranteed to be atomic. LibraryStore \u00b6 LibraryStore s provide an interface with a huge amount of data, through a single \"key\", without a version history. It is suited to an extremely amount of data, for example a map layout, or contents of several player-maintained encyclopaedias. It uses multiple GetAsync calls per PullData call, and the same applies to the SetAsync calls with PushData . It has no exposed UpdateData method since it would defeat the benefits of using UpdateAsync since there is no way to implement an all or nothing atomic call to poll all keys used by the store. Data Management \u00b6 Session Locking \u00b6 Session locking avoids data loss or duplication by detecting when a server on ROBLOX either crashed or the save failed. It is a rather simple thing to implement. Firstly, you'd have a section of your data within a TrackedStore , multi or single, dedicated to session locking: SessionData : { Session : JobId JoinKey : SaveKey SessionTransactions : <array TransactionId> } If a Session still exists in the data within the SessionData, then the data didn't save properly. In an atomic database, this is a big issue, as it could lead to item duplication or loss, or just unwanted data interactions in general. Therefore, by tracking SessionTransactions , you can find the transactions performed in this session, and roll them back. Then, you can roll back the rest of the player data, back to the JoinKey, using the PullDataFromKey and PushData functions of a TrackedStore . For even more control, you can use the function GetSaveKeys to extract keys from a specified depth in the VersionHistory . If you need more information, this article sums up Session Locking pretty well: https://devforum.roblox.com/t/session-locking-explained-datastore/846799 Data Rollbacks \u00b6 If for whatever reason, a user needed to have their data rolled back to a previous state, you could use a TrackedMultiStore or a TrackedStore to do just this. By storing a list of transactions within the data system, you could then roll back these transactions by finding the relevant TransactionId in a transaction MultiStore and then essentially rewind time and pull back all of the items that the player had, into their inventory, without creating duplicate items ever. It would require you to have a MultiStore for both Items and Transactions, and to track SessionTransactions for a user.","title":"Best Practices"},{"location":"Resources/BestPractices/#best-practices","text":"","title":"Best Practices"},{"location":"Resources/BestPractices/#failure-detection","text":"Failures are all wrapped in pcalls and are detected when you receive a value of false from the PullData / PushData / UpdateData call, followed by an error message. Here's an example: local data , code = GeneralStore : PullData () if data == false then -- failed elseif data == nil then -- no data else -- data end For this reason storing false by itself will lead to ambiguities Try to avoid storing boolean values directly since it will interfere with your error catching/monitoring.","title":"Failure Detection"},{"location":"Resources/BestPractices/#store-usage","text":"","title":"Store Usage"},{"location":"Resources/BestPractices/#generalstore","text":"GeneralStore s provide an interface with a small amount of data, through a single key, with no history. This means that they are not ideal for saving whole sets of player data, but are instead suited more to saving single entities.","title":"GeneralStore"},{"location":"Resources/BestPractices/#multistore","text":"MultiStore s provide an interface with a small amount of data, through many keys, with no history. This means that they are ideal for tracking multi-key entities such as Items, with each UID having their own keys. If Atomicity is important, use UpdateData in preference to PullData / PushData This is due to UpdateData exposing the inbuilt UpdateAsync method, which A) doesn't cache, B) doesn't have the same 6 second key limit, C) retries until it performs its intended purpose, D) is cancellable, by returning nil .","title":"MultiStore"},{"location":"Resources/BestPractices/#trackedstore","text":"TrackedStore s provide an interface with a large amount of data, through a single key, with a version history. This means it is suited to storing a regular amount of player data, in a regular game scenario, and since it has a 1:1 PullData - GetAsync call ratio, it will not consume your data budgets unnecessarily. You're advised to use this as a main data store, and not an entity store Access it using PullData and PushData and apply session locking with UpdateData since pulling and pushing isn't guaranteed to be atomic.","title":"TrackedStore"},{"location":"Resources/BestPractices/#trackedmultistore","text":"TrackedMultiStore s provide an interface with an even larger amount of data, through multiple keys, with a shared version history. It is suited to a large amount of player data, such as storing house arrangements, since it has a 1:many PullData - GetAsync call ratio, it is advised to use TrackedStores wherever possible. You're advised to use this as a main data store, and not an entity store Access it using PullData and PushData and apply session locking with UpdateData since pulling and pushing isn't guaranteed to be atomic.","title":"TrackedMultiStore"},{"location":"Resources/BestPractices/#librarystore","text":"LibraryStore s provide an interface with a huge amount of data, through a single \"key\", without a version history. It is suited to an extremely amount of data, for example a map layout, or contents of several player-maintained encyclopaedias. It uses multiple GetAsync calls per PullData call, and the same applies to the SetAsync calls with PushData . It has no exposed UpdateData method since it would defeat the benefits of using UpdateAsync since there is no way to implement an all or nothing atomic call to poll all keys used by the store.","title":"LibraryStore"},{"location":"Resources/BestPractices/#data-management","text":"","title":"Data Management"},{"location":"Resources/BestPractices/#session-locking","text":"Session locking avoids data loss or duplication by detecting when a server on ROBLOX either crashed or the save failed. It is a rather simple thing to implement. Firstly, you'd have a section of your data within a TrackedStore , multi or single, dedicated to session locking: SessionData : { Session : JobId JoinKey : SaveKey SessionTransactions : <array TransactionId> } If a Session still exists in the data within the SessionData, then the data didn't save properly. In an atomic database, this is a big issue, as it could lead to item duplication or loss, or just unwanted data interactions in general. Therefore, by tracking SessionTransactions , you can find the transactions performed in this session, and roll them back. Then, you can roll back the rest of the player data, back to the JoinKey, using the PullDataFromKey and PushData functions of a TrackedStore . For even more control, you can use the function GetSaveKeys to extract keys from a specified depth in the VersionHistory . If you need more information, this article sums up Session Locking pretty well: https://devforum.roblox.com/t/session-locking-explained-datastore/846799","title":"Session Locking"},{"location":"Resources/BestPractices/#data-rollbacks","text":"If for whatever reason, a user needed to have their data rolled back to a previous state, you could use a TrackedMultiStore or a TrackedStore to do just this. By storing a list of transactions within the data system, you could then roll back these transactions by finding the relevant TransactionId in a transaction MultiStore and then essentially rewind time and pull back all of the items that the player had, into their inventory, without creating duplicate items ever. It would require you to have a MultiStore for both Items and Transactions, and to track SessionTransactions for a user.","title":"Data Rollbacks"},{"location":"Resources/Examples/","text":"Examples \u00b6 Session Lock \u00b6 Transactional Database Structure \u00b6","title":"Examples"},{"location":"Resources/Examples/#examples","text":"","title":"Examples"},{"location":"Resources/Examples/#session-lock","text":"","title":"Session Lock"},{"location":"Resources/Examples/#transactional-database-structure","text":"","title":"Transactional Database Structure"}]}